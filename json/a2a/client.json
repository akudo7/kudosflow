{
  "config": {
    "recursionLimit": 100,
    "eventEmitter": {
      "defaultMaxListeners": 20
    }
  },
  "stateAnnotation": {
    "name": "AgentState",
    "type": "Annotation.Root"
  },
  "annotation": {
    "messages": {
      "type": "BaseMessage[]",
      "reducer": "(x, y) => x.concat(y)",
      "default": []
    },
    "currentPhase": {
      "type": "string",
      "reducer": "(x, y) => y || x",
      "default": "task_creation"
    },
    "taskServerResponse": {
      "type": "any",
      "reducer": "(x, y) => y || x",
      "default": null
    },
    "researchServerResponse": {
      "type": "any",
      "reducer": "(x, y) => y || x",
      "default": null
    },
    "evaluationServerResponse": {
      "type": "any",
      "reducer": "(x, y) => y || x",
      "default": null
    },
    "userDecision": {
      "type": "string",
      "reducer": "(x, y) => y || x",
      "default": null
    },
    "userFeedback": {
      "type": "string",
      "reducer": "(x, y) => y || x",
      "default": null
    },
    "reportData": {
      "type": "any",
      "reducer": "(x, y) => y || x",
      "default": null
    },
    "reportText": {
      "type": "string",
      "reducer": "(x, y) => y || x",
      "default": null
    }
  },
  "models": [
    {
      "id": "mainModel",
      "type": "OpenAI",
      "config": {
        "model": "gpt-4o-mini",
        "temperature": 0.3
      },
      "bindA2AServers": true,
      "systemPrompt": "You are an orchestrator for a multi-agent research system with three specialized agents: TaskCreationAgent, ResearchExecutionAgent, and QualityEvaluationAgent."
    }
  ],
  "nodes": [
    {
      "id": "orchestrator",
      "handler": {
        "parameters": [
          {
            "name": "state",
            "parameterType": "state",
            "stateType": "typeof AgentState.State"
          },
          {
            "name": "model",
            "parameterType": "model",
            "modelRef": "mainModel"
          }
        ],
        "function": "try {\n  console.log('ðŸŽ¯ [orchestrator] Phase:', state.currentPhase, 'UserDecision:', state.userDecision);\n  \n  const currentPhase = state.currentPhase || 'task_creation';\n  \n  if (currentPhase === 'task_creation') {\n    console.log('ðŸ“‹ [orchestrator] Invoking TaskCreationAgent');\n    console.log('ðŸ” [orchestrator] state.messages:', JSON.stringify(state.messages, null, 2));\n    \n    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¤‡æ•°ã®æ–¹æ³•ã§å–å¾—ã‚’è©¦ã¿ã‚‹\n    let userMessage = null;\n    \n    // æ–¹æ³•1: role === 'user'ã§æ¤œç´¢\n    const userMsg1 = state.messages.find(msg => msg.role === 'user');\n    if (userMsg1) {\n      userMessage = userMsg1.content || userMsg1.text || null;\n      console.log('âœ“ [orchestrator] Found user message (method 1):', userMessage?.substring(0, 100));\n    }\n    \n    // æ–¹æ³•2: æœ€åˆã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å–å¾—\n    if (!userMessage && state.messages.length > 0) {\n      const firstMsg = state.messages[0];\n      userMessage = firstMsg.content || firstMsg.text || null;\n      console.log('âœ“ [orchestrator] Found user message (method 2):', userMessage?.substring(0, 100));\n    }\n    \n    if (!userMessage) {\n      console.error('âŒ [orchestrator] Could not find user message');\n      throw new Error('ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚state.messagesã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');\n    }\n    \n    let prompt = userMessage;\n    if (state.userFeedback) {\n      prompt = `å‰å›žã®ã‚¿ã‚¹ã‚¯ãƒªã‚¹ãƒˆã¸ã®ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯: ${state.userFeedback}\\n\\nå…ƒã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆ: ${userMessage}`;\n      console.log('ðŸ”„ [orchestrator] Retry with feedback');\n    }\n    \n    const response = await model.invoke([\n      { role: 'system', content: 'You MUST use ONLY the send_message_to_task_agent tool. Do not use any other tools.' },\n      { role: 'user', content: prompt }\n    ]);\n    return { messages: [response], currentPhase: 'task_creation', userFeedback: null };\n  }\n  \n  if (currentPhase === 'research_execution') {\n    console.log('ðŸ” [orchestrator] Invoking ResearchExecutionAgent');\n    const taskListStr = JSON.stringify(state.taskServerResponse, null, 2);\n    \n    let prompt = `ä»¥ä¸‹ã®ã‚¿ã‚¹ã‚¯ãƒªã‚¹ãƒˆã«åŸºã¥ã„ã¦èª¿æŸ»ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„:\\n${taskListStr}`;\n    if (state.userFeedback) {\n      prompt = `å‰å›žã®èª¿æŸ»ã¸ã®ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯: ${state.userFeedback}\\n\\n${prompt}`;\n      console.log('ðŸ”„ [orchestrator] Retry research with feedback');\n    }\n    \n    const response = await model.invoke([\n      { role: 'system', content: 'You MUST use ONLY the send_message_to_research_agent tool. Do not use any other tools.' },\n      { role: 'user', content: prompt }\n    ]);\n    return { messages: [response], currentPhase: 'research_execution', userFeedback: null };\n  }\n  \n  if (currentPhase === 'quality_evaluation') {\n    console.log('âœ… [orchestrator] Invoking QualityEvaluationAgent');\n\n    // å…¨ã¦ã®èª¿æŸ»çµæžœã‚’åŽé›†ã—ã¦ã¾ã¨ã‚ã‚‹\n    const allResearchResults = state.messages\n      .filter(msg => (msg._getType && msg._getType() === 'tool') || msg.role === 'tool')\n      .filter(msg => msg.name === 'send_message_to_research_agent')\n      .map(msg => {\n        try {\n          const parsed = typeof msg.content === 'string' ? JSON.parse(msg.content) : msg.content;\n          return parsed;\n        } catch (e) {\n          console.error('âŒ [orchestrator] Failed to parse research result:', e);\n          return null;\n        }\n      })\n      .filter(Boolean);\n\n    console.log(`ðŸ“Š [orchestrator] Collected ${allResearchResults.length} research results`);\n\n    // å…ƒã®ãƒ¦ãƒ¼ã‚¶è¦æ±‚ã‚’å–å¾—\n    const originalRequest = state.messages.find(msg => msg.role === 'user')?.content || '';\n\n    // èª¿æŸ»çµæžœã‚’äº‹å‰ã«æŠ½å‡ºï¼ˆãƒã‚¹ãƒˆã•ã‚ŒãŸJSONã‚’è§£æ±ºï¼‰\n    const extractedResults = [];\n\n    for (const item of allResearchResults) {\n      try {\n        if (item.response && item.response.content) {\n          const contentData = JSON.parse(item.response.content);\n          if (contentData.result && contentData.result.messages) {\n            const assistantMsg = contentData.result.messages.find(m => m.role === 'assistant');\n            if (assistantMsg && assistantMsg.content) {\n              const researchData = JSON.parse(assistantMsg.content);\n              if (researchData.result && researchData.result.researchResults) {\n                extractedResults.push(...researchData.result.researchResults);\n              }\n            }\n          }\n        }\n      } catch (e) {\n        console.error('âŒ [orchestrator] Failed to extract research result:', e);\n      }\n    }\n\n    console.log(`ðŸ“Š [orchestrator] Extracted ${extractedResults.length} research findings`);\n\n    // å“è³ªè©•ä¾¡ç”¨ã®ãƒ‡ãƒ¼ã‚¿ã‚’æ§‹ç¯‰ï¼ˆã‚·ãƒ³ãƒ—ãƒ«ã§ãƒ•ãƒ©ãƒƒãƒˆãªæ§‹é€ ï¼‰\n    const evaluationData = {\n      originalRequest,\n      researchResults: extractedResults,\n      totalResults: extractedResults.length\n    };\n\n    const evaluationStr = JSON.stringify(evaluationData, null, 2);\n\n    let prompt = `ä»¥ä¸‹ã®èª¿æŸ»çµæžœã®å“è³ªã‚’è©•ä¾¡ã—ã€ã‚¨ã‚°ã‚¼ã‚¯ãƒ†ã‚£ãƒ–ã‚µãƒžãƒªãƒ¼ã‚’ä½œæˆã—ã¦ãã ã•ã„:\\n${evaluationStr}`;\n    if (state.userFeedback) {\n      prompt = `å‰å›žã®è©•ä¾¡ã¸ã®ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯: ${state.userFeedback}\\n\\n${prompt}`;\n      console.log('ðŸ”„ [orchestrator] Retry evaluation with feedback');\n    }\n\n    const response = await model.invoke([\n      { role: 'system', content: 'You MUST use ONLY the send_message_to_quality_agent tool. Do not use any other tools.' },\n      { role: 'user', content: prompt }\n    ]);\n    return { messages: [response], currentPhase: 'quality_evaluation', userFeedback: null };\n  }\n  \n  console.log('ðŸŽ¯ [orchestrator] No action needed, phase:', currentPhase);\n  return { messages: [], currentPhase };\n}\ncatch (error) {\n  console.error('âŒ [orchestrator] Error:', error);\n  return { \n    messages: [{ role: 'assistant', content: `Error: ${error.message}` }],\n    currentPhase: 'error'\n  };\n}"
      }
    },
    {
      "id": "tools",
      "type": "ToolNode",
      "useA2AServers": true
    },
    {
      "id": "approval_gate_task",
      "handler": {
        "parameters": [
          {
            "name": "state",
            "parameterType": "state",
            "stateType": "typeof AgentState.State"
          }
        ],
        "function": "console.log('ðŸšª [approval_gate_task] Processing task approval');\n\nconst lastToolResult = state.messages\n  .filter(msg => (msg._getType && msg._getType() === 'tool') || msg.role === 'tool')\n  .filter(msg => msg.name === 'send_message_to_task_agent')\n  .pop();\n\nif (!lastToolResult) {\n  console.log('âš ï¸  [approval_gate_task] No task agent response found');\n  return { messages: [], userDecision: null, currentPhase: state.currentPhase };\n}\n\nconsole.log('ðŸ“‹ [approval_gate_task] Task agent response received');\n\nlet parsedContent;\ntry {\n  parsedContent = typeof lastToolResult.content === 'string' \n    ? JSON.parse(lastToolResult.content) \n    : lastToolResult.content;\n} catch (e) {\n  console.error('âŒ [approval_gate_task] Parse error:', e);\n  return { messages: [], userDecision: null, currentPhase: state.currentPhase };\n}\n\nlet taskList = [];\nif (parsedContent.response && parsedContent.response.content) {\n  try {\n    const responseContent = typeof parsedContent.response.content === 'string'\n      ? JSON.parse(parsedContent.response.content)\n      : parsedContent.response.content;\n    \n    if (responseContent.result && responseContent.result.messages) {\n      const assistantMsg = responseContent.result.messages.find(m => m.role === 'assistant');\n      if (assistantMsg && assistantMsg.content) {\n        const innerContent = typeof assistantMsg.content === 'string'\n          ? JSON.parse(assistantMsg.content)\n          : assistantMsg.content;\n        taskList = innerContent.result?.taskList || innerContent.taskList || [];\n      }\n    }\n  } catch (e) {\n    console.error('âŒ [approval_gate_task] Could not parse content:', e);\n  }\n}\n\nif (taskList.length === 0) {\n  console.log('âš ï¸  [approval_gate_task] Empty task list');\n  return { messages: [], userDecision: null, currentPhase: state.currentPhase };\n}\n\nconst taskSummary = taskList.map((t, i) => \n  `${i + 1}. ${t.objective} (${t.estimated_effort || 'N/A'})`\n).join('\\n');\n\nconst totalHours = taskList.reduce((sum, t) => {\n  const hours = parseInt(t.estimated_effort) || 0;\n  return sum + hours;\n}, 0);\n\nconst message = `ðŸ“‹ ã‚¿ã‚¹ã‚¯ãƒªã‚¹ãƒˆä½œæˆå®Œäº†\\n\\n` +\n                `åˆè¨ˆã‚¿ã‚¹ã‚¯æ•°: ${taskList.length}\\n` +\n                `äºˆæƒ³æ™‚é–“: ${totalHours}æ™‚é–“\\n\\n` +\n                `ã‚¿ã‚¹ã‚¯:\\n${taskSummary}\\n\\n` +\n                `ã“ã®ã‚¿ã‚¹ã‚¯ãƒªã‚¹ãƒˆã§èª¿æŸ»ã‚’é€²ã‚ã¾ã™ã‹?\\n` +\n                `ãƒ»ã€Œè¨±å¯ã€ã¨å…¥åŠ›ã™ã‚‹ã¨èª¿æŸ»ã‚’é–‹å§‹ã—ã¾ã™\\n` +\n                `ãƒ»ãã®ä»–ã®å…¥åŠ›ã§ã‚¿ã‚¹ã‚¯ã‚’å†ç”Ÿæˆã—ã¾ã™`;\n\nconsole.log('â¸ï¸  [approval_gate_task] Requesting approval');\nconst userResponse = interrupt(message);\nconsole.log('âœ… [approval_gate_task] User response:', userResponse);\n\nif (!userResponse) {\n  return {\n    messages: [],\n    userDecision: 'pending',\n    currentPhase: state.currentPhase,\n    taskServerResponse: parsedContent\n  };\n}\n\nconst response = String(userResponse).toLowerCase().trim();\nif (response === 'approve' || response === 'è¨±å¯' || response.includes('è¨±å¯')) {\n  console.log('âœ… [approval_gate_task] Approved - moving to research');\n  return {\n    messages: [],\n    userDecision: 'approve',\n    currentPhase: 'research_execution',\n    taskServerResponse: parsedContent,\n    userFeedback: null\n  };\n} else {\n  console.log('âŒ [approval_gate_task] Rejected - retrying task creation');\n  return {\n    messages: [],\n    userDecision: 'reject',\n    currentPhase: 'task_creation',\n    taskServerResponse: parsedContent,\n    userFeedback: userResponse\n  };\n}"
      }
    },
    {
      "id": "approval_gate_research",
      "handler": {
        "parameters": [
          {
            "name": "state",
            "parameterType": "state",
            "stateType": "typeof AgentState.State"
          }
        ],
        "function": "console.log('ðŸšª [approval_gate_research] Processing research approval');\n\nconst lastToolResult = state.messages\n  .filter(msg => (msg._getType && msg._getType() === 'tool') || msg.role === 'tool')\n  .filter(msg => msg.name === 'send_message_to_research_agent')\n  .pop();\n\nif (!lastToolResult) {\n  console.log('âš ï¸  [approval_gate_research] No research agent response found');\n  return { messages: [], userDecision: null, currentPhase: state.currentPhase };\n}\n\nconsole.log('ðŸ” [approval_gate_research] Research agent response received');\n\nlet parsedContent;\ntry {\n  parsedContent = typeof lastToolResult.content === 'string'\n    ? JSON.parse(lastToolResult.content)\n    : lastToolResult.content;\n} catch (e) {\n  console.error('âŒ [approval_gate_research] Parse error:', e);\n  return { messages: [], userDecision: null, currentPhase: state.currentPhase };\n}\n\nlet researchResults = [];\nlet summary = '';\nif (parsedContent.response && parsedContent.response.content) {\n  try {\n    const responseContent = typeof parsedContent.response.content === 'string'\n      ? JSON.parse(parsedContent.response.content)\n      : parsedContent.response.content;\n    \n    if (responseContent.result && responseContent.result.messages) {\n      const assistantMsg = responseContent.result.messages.find(m => m.role === 'assistant');\n      if (assistantMsg && assistantMsg.content) {\n        const innerContent = typeof assistantMsg.content === 'string'\n          ? JSON.parse(assistantMsg.content)\n          : assistantMsg.content;\n        researchResults = innerContent.result?.researchResults || innerContent.researchResults || [];\n        summary = innerContent.result?.summary || innerContent.summary || '';\n      }\n    }\n  } catch (e) {\n    console.error('âŒ [approval_gate_research] Could not parse content:', e);\n  }\n}\n\nif (researchResults.length === 0) {\n  console.log('âš ï¸  [approval_gate_research] Empty research results');\n  return { messages: [], userDecision: null, currentPhase: state.currentPhase };\n}\n\nconst resultSummary = researchResults.map((r, i) =>\n  `${i + 1}. ${r.objective}\\n   ${r.findings.substring(0, 100)}...`\n).join('\\n\\n');\n\nconst message = `ðŸ” èª¿æŸ»å®Ÿè¡Œå®Œäº†\\n\\n` +\n                `å®Œäº†ã‚¿ã‚¹ã‚¯æ•°: ${researchResults.length}\\n\\n` +\n                `èª¿æŸ»çµæžœ:\\n${resultSummary}\\n\\n` +\n                `ã‚µãƒžãƒªãƒ¼: ${summary}\\n\\n` +\n                `ã“ã®èª¿æŸ»çµæžœã§è©•ä¾¡ã«é€²ã¿ã¾ã™ã‹?\\n` +\n                `ãƒ»ã€Œè¨±å¯ã€ã¨å…¥åŠ›ã™ã‚‹ã¨å“è³ªè©•ä¾¡ã‚’é–‹å§‹ã—ã¾ã™\\n` +\n                `ãƒ»ãã®ä»–ã®å…¥åŠ›ã§èª¿æŸ»ã‚’å†å®Ÿè¡Œã—ã¾ã™`;\n\nconsole.log('â¸ï¸  [approval_gate_research] Requesting approval');\nconst userResponse = interrupt(message);\nconsole.log('âœ… [approval_gate_research] User response:', userResponse);\n\nif (!userResponse) {\n  return {\n    messages: [],\n    userDecision: 'pending',\n    currentPhase: state.currentPhase,\n    researchServerResponse: parsedContent\n  };\n}\n\nconst response = String(userResponse).toLowerCase().trim();\nif (response === 'approve' || response === 'è¨±å¯' || response.includes('è¨±å¯')) {\n  console.log('âœ… [approval_gate_research] Approved - moving to evaluation');\n  return {\n    messages: [],\n    userDecision: 'approve',\n    currentPhase: 'quality_evaluation',\n    researchServerResponse: parsedContent,\n    userFeedback: null\n  };\n} else {\n  console.log('âŒ [approval_gate_research] Rejected - retrying research');\n  return {\n    messages: [],\n    userDecision: 'reject',\n    currentPhase: 'research_execution',\n    researchServerResponse: parsedContent,\n    userFeedback: userResponse\n  };\n}"
      }
    },
    {
      "id": "report_generator",
      "handler": {
        "parameters": [
          {
            "name": "state",
            "parameterType": "state",
            "stateType": "typeof AgentState.State"
          }
        ],
        "function": "console.log('ðŸ“Š [report_generator] ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆé–‹å§‹');\n\n// å…¨ã¦ã®èª¿æŸ»çµæžœã‚’åŽé›†\nconst allResearchResults = state.messages\n  .filter(msg => (msg._getType && msg._getType() === 'tool') || msg.role === 'tool')\n  .filter(msg => msg.name === 'send_message_to_research_agent')\n  .map(msg => {\n    try {\n      const parsed = typeof msg.content === 'string' ? JSON.parse(msg.content) : msg.content;\n      return parsed;\n    } catch (e) {\n      console.error('âŒ [report_generator] Failed to parse research result:', e);\n      return null;\n    }\n  })\n  .filter(Boolean);\n\nconsole.log(`ðŸ“Š [report_generator] Collected ${allResearchResults.length} research results`);\n\n// å…ƒã®ãƒ¦ãƒ¼ã‚¶è¦æ±‚ã‚’å–å¾—\nconst originalRequest = state.messages.find(msg => msg.role === 'user')?.content || '';\n\n// èª¿æŸ»çµæžœã‚’æŠ½å‡ºï¼ˆãƒã‚¹ãƒˆã•ã‚ŒãŸJSONã‚’è§£æ±ºï¼‰\nconst extractedResults = [];\n\nfor (const item of allResearchResults) {\n  try {\n    if (item.response && item.response.content) {\n      const contentData = JSON.parse(item.response.content);\n      if (contentData.result && contentData.result.messages) {\n        const assistantMsg = contentData.result.messages.find(m => m.role === 'assistant');\n        if (assistantMsg && assistantMsg.content) {\n          const researchData = JSON.parse(assistantMsg.content);\n          if (researchData.result && researchData.result.researchResults) {\n            extractedResults.push(...researchData.result.researchResults);\n          }\n        }\n      }\n    }\n  } catch (e) {\n    console.error('âŒ [report_generator] Failed to extract research result:', e);\n  }\n}\n\nconsole.log(`ðŸ“Š [report_generator] Extracted ${extractedResults.length} research findings`);\n\n// çµ±è¨ˆæƒ…å ±ã‚’è¨ˆç®—\nconst totalResults = extractedResults.length;\nconst totalCharacters = extractedResults.reduce((sum, r) => sum + (r.findings?.length || 0), 0);\n\n// çµ±åˆãƒ¬ãƒãƒ¼ãƒˆã‚’ç”Ÿæˆ\nlet reportText = '# èª¿æŸ»ãƒ¬ãƒãƒ¼ãƒˆ\\n\\n';\nreportText += '## æ¦‚è¦\\n\\n';\nreportText += `**å…ƒã®ãƒ¦ãƒ¼ã‚¶è¦æ±‚**: ${originalRequest}\\n\\n`;\nreportText += `**å®Œäº†ã‚¿ã‚¹ã‚¯æ•°**: ${totalResults}\\n`;\nreportText += `**ç·æ–‡å­—æ•°**: ${totalCharacters.toLocaleString()}æ–‡å­—\\n\\n`;\n\nreportText += '## èª¿æŸ»çµæžœã‚µãƒžãƒªãƒ¼\\n\\n';\nextractedResults.forEach((r, i) => {\n  reportText += `${i + 1}. **${r.objective}**\\n`;\n  const summary = r.findings.substring(0, 150);\n  reportText += `   ${summary}${r.findings.length > 150 ? '...' : ''}\\n\\n`;\n});\n\nreportText += '## è©³ç´°ãªèª¿æŸ»çµæžœ\\n\\n';\nextractedResults.forEach((r, i) => {\n  reportText += `### ã‚¿ã‚¹ã‚¯${i + 1}: ${r.objective}\\n\\n`;\n  reportText += `${r.findings}\\n\\n`;\n  if (r.sources && r.sources.length > 0) {\n    reportText += `**å‡ºå…¸**:\\n`;\n    r.sources.forEach(src => {\n      reportText += `- ${src}\\n`;\n    });\n    reportText += '\\n';\n  }\n});\n\n// ãƒ•ãƒ©ãƒƒãƒˆåŒ–ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’ä½œæˆ\nconst reportData = {\n  originalRequest,\n  researchResults: extractedResults,\n  totalResults,\n  totalCharacters\n};\n\nconsole.log('âœ… [report_generator] ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆå®Œäº†');\nconsole.log(`  - ã‚¿ã‚¹ã‚¯æ•°: ${totalResults}`);\nconsole.log(`  - ç·æ–‡å­—æ•°: ${totalCharacters}`);\nconsole.log(`  - ãƒ¬ãƒãƒ¼ãƒˆé•·: ${reportText.length} chars`);\n\nreturn {\n  messages: [],\n  reportData,\n  reportText,\n  currentPhase: state.currentPhase\n};"
      }
    },
    {
      "id": "approval_gate_report",
      "handler": {
        "parameters": [
          {
            "name": "state",
            "parameterType": "state",
            "stateType": "typeof AgentState.State"
          }
        ],
        "function": "console.log('ðŸšª [approval_gate_report] Processing report approval');\n\nif (!state.reportText) {\n  console.log('âš ï¸  [approval_gate_report] No report text found');\n  return { messages: [], userDecision: null, currentPhase: state.currentPhase };\n}\n\nconsole.log('ðŸ“Š [approval_gate_report] Report generated');\n\nconst message = `ðŸ“Š èª¿æŸ»ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆå®Œäº†\\n\\n` +\n                `ã‚¿ã‚¹ã‚¯å®Œäº†æ•°: ${state.reportData?.totalResults || 0}\\n` +\n                `ç·æ–‡å­—æ•°: ${(state.reportData?.totalCharacters || 0).toLocaleString()}\\n\\n` +\n                `${state.reportText}\\n\\n` +\n                `ã“ã®ãƒ¬ãƒãƒ¼ãƒˆã§å“è³ªè©•ä¾¡ã«é€²ã¿ã¾ã™ã‹?\\n` +\n                `ãƒ»ã€Œè¨±å¯ã€ã¨å…¥åŠ›ã™ã‚‹ã¨å“è³ªè©•ä¾¡ã‚’é–‹å§‹ã—ã¾ã™\\n` +\n                `ãƒ»ãã®ä»–ã®å…¥åŠ›ã§èª¿æŸ»ã‚’å†å®Ÿè¡Œã—ã¾ã™`;\n\nconsole.log('â¸ï¸  [approval_gate_report] Requesting approval');\nconst userResponse = interrupt(message);\nconsole.log('âœ… [approval_gate_report] User response:', userResponse);\n\nif (!userResponse) {\n  return {\n    messages: [],\n    userDecision: 'pending',\n    currentPhase: state.currentPhase\n  };\n}\n\nconst response = String(userResponse).toLowerCase().trim();\nif (response === 'approve' || response === 'è¨±å¯' || response.includes('è¨±å¯')) {\n  console.log('âœ… [approval_gate_report] Approved - moving to quality evaluation');\n  return {\n    messages: [],\n    userDecision: 'approve',\n    currentPhase: 'quality_evaluation',\n    userFeedback: null\n  };\n} else {\n  console.log('âŒ [approval_gate_report] Rejected - retrying research');\n  return {\n    messages: [],\n    userDecision: 'reject',\n    currentPhase: 'research_execution',\n    userFeedback: userResponse\n  };\n}"
      }
    },
    {
      "id": "approval_gate_evaluation",
      "handler": {
        "parameters": [
          {
            "name": "state",
            "parameterType": "state",
            "stateType": "typeof AgentState.State"
          }
        ],
        "function": "console.log('ðŸšª [approval_gate_evaluation] Processing evaluation approval');\n\nconst lastToolResult = state.messages\n  .filter(msg => (msg._getType && msg._getType() === 'tool') || msg.role === 'tool')\n  .filter(msg => msg.name === 'send_message_to_quality_agent')\n  .pop();\n\nif (!lastToolResult) {\n  console.log('âš ï¸  [approval_gate_evaluation] No quality agent response found');\n  return { messages: [], userDecision: null, currentPhase: state.currentPhase };\n}\n\nconsole.log('âœ… [approval_gate_evaluation] Quality agent response received');\n\nlet parsedContent;\ntry {\n  parsedContent = typeof lastToolResult.content === 'string'\n    ? JSON.parse(lastToolResult.content)\n    : lastToolResult.content;\n} catch (e) {\n  console.error('âŒ [approval_gate_evaluation] Parse error:', e);\n  return { messages: [], userDecision: null, currentPhase: state.currentPhase };\n}\n\nlet qualityScore = 0;\nlet executiveSummary = '';\nlet recommendations = [];\nlet missingTopics = [];\n\nif (parsedContent.response && parsedContent.response.content) {\n  try {\n    const responseContent = typeof parsedContent.response.content === 'string'\n      ? JSON.parse(parsedContent.response.content)\n      : parsedContent.response.content;\n    \n    if (responseContent.result && responseContent.result.messages) {\n      const assistantMsg = responseContent.result.messages.find(m => m.role === 'assistant');\n      if (assistantMsg && assistantMsg.content) {\n        const innerContent = typeof assistantMsg.content === 'string'\n          ? JSON.parse(assistantMsg.content)\n          : assistantMsg.content;\n        const result = innerContent.result || innerContent;\n        qualityScore = result.qualityScore || 0;\n        executiveSummary = result.executiveSummary || '';\n        recommendations = result.recommendations || [];\n        missingTopics = result.missingTopics || [];\n      }\n    }\n  } catch (e) {\n    console.error('âŒ [approval_gate_evaluation] Could not parse content:', e);\n  }\n}\n\nconst recList = recommendations.length > 0\n  ? recommendations.map((r, i) => `  ${i + 1}. ${r}`).join('\\n')\n  : '  ãªã—';\n\nconst missingList = missingTopics.length > 0\n  ? missingTopics.join(', ')\n  : 'ãªã—';\n\nconst message = `âœ… å“è³ªè©•ä¾¡å®Œäº†\\n\\n` +\n                `å“è³ªã‚¹ã‚³ã‚¢: ${qualityScore}/100\\n\\n` +\n                `ã‚¨ã‚°ã‚¼ã‚¯ãƒ†ã‚£ãƒ–ã‚µãƒžãƒªãƒ¼:\\n${executiveSummary}\\n\\n` +\n                `æŽ¨å¥¨äº‹é …:\\n${recList}\\n\\n` +\n                `ä¸è¶³ãƒˆãƒ”ãƒƒã‚¯: ${missingList}\\n\\n` +\n                `ã“ã®è©•ä¾¡çµæžœã§å®Œäº†ã—ã¾ã™ã‹?\\n` +\n                `ãƒ»ã€Œè¨±å¯ã€ã¨å…¥åŠ›ã™ã‚‹ã¨ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚’å®Œäº†ã—ã¾ã™\\n` +\n                `ãƒ»ãã®ä»–ã®å…¥åŠ›ã§è©•ä¾¡ã‚’å†å®Ÿè¡Œã—ã¾ã™`;\n\nconsole.log('â¸ï¸  [approval_gate_evaluation] Requesting approval');\nconst userResponse = interrupt(message);\nconsole.log('âœ… [approval_gate_evaluation] User response:', userResponse);\n\nif (!userResponse) {\n  return {\n    messages: [],\n    userDecision: 'pending',\n    currentPhase: state.currentPhase,\n    evaluationServerResponse: parsedContent\n  };\n}\n\nconst response = String(userResponse).toLowerCase().trim();\nif (response === 'approve' || response === 'è¨±å¯' || response.includes('è¨±å¯')) {\n  console.log('âœ… [approval_gate_evaluation] Approved - workflow completed');\n  return {\n    messages: [{ role: 'assistant', content: 'âœ… ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ãŒæ­£å¸¸ã«å®Œäº†ã—ã¾ã—ãŸã€‚' }],\n    userDecision: 'approve',\n    currentPhase: 'completed',\n    evaluationServerResponse: parsedContent,\n    userFeedback: null\n  };\n} else {\n  console.log('âŒ [approval_gate_evaluation] Rejected - retrying evaluation');\n  return {\n    messages: [],\n    userDecision: 'reject',\n    currentPhase: 'quality_evaluation',\n    evaluationServerResponse: parsedContent,\n    userFeedback: userResponse\n  };\n}"
      }
    }
  ],
  "edges": [
    {
      "from": "__start__",
      "to": "orchestrator"
    },
    {
      "from": "orchestrator",
      "type": "conditional",
      "condition": {
        "name": "routeAfterOrchestrator",
        "handler": {
          "parameters": [
            {
              "name": "state",
              "parameterType": "state",
              "stateType": "typeof AgentState.State"
            }
          ],
          "function": "const lastMessage = state.messages[state.messages.length - 1];\nif (lastMessage && lastMessage.tool_calls && lastMessage.tool_calls.length > 0) {\n  return 'tools';\n}\nif (state.currentPhase === 'error' || state.currentPhase === 'completed') {\n  return '__end__';\n}\nreturn '__end__';"
        }
      }
    },
    {
      "from": "tools",
      "type": "conditional",
      "condition": {
        "name": "routeAfterTools",
        "handler": {
          "parameters": [
            {
              "name": "state",
              "parameterType": "state",
              "stateType": "typeof AgentState.State"
            }
          ],
          "function": "const lastToolResult = state.messages\n  .filter(msg => (msg._getType && msg._getType() === 'tool') || msg.role === 'tool')\n  .pop();\n\nif (!lastToolResult) {\n  return '__end__';\n}\n\nif (lastToolResult.name === 'send_message_to_task_agent') {\n  return 'approval_gate_task';\n}\nif (lastToolResult.name === 'send_message_to_research_agent') {\n  return 'approval_gate_research';\n}\nif (lastToolResult.name === 'send_message_to_quality_agent') {\n  return 'approval_gate_evaluation';\n}\n\nreturn '__end__';"
        }
      }
    },
    {
      "from": "approval_gate_task",
      "to": "orchestrator"
    },
    {
      "from": "approval_gate_research",
      "type": "conditional",
      "condition": {
        "name": "routeAfterResearchApproval",
        "handler": {
          "parameters": [
            {
              "name": "state",
              "parameterType": "state",
              "stateType": "typeof AgentState.State"
            }
          ],
          "function": "if (state.userDecision === 'approve') { return 'report_generator'; } return 'orchestrator';"
        }
      }
    },
    {
      "from": "report_generator",
      "to": "approval_gate_report"
    },
    {
      "from": "approval_gate_report",
      "to": "orchestrator"
    },
    {
      "from": "approval_gate_evaluation",
      "type": "conditional",
      "condition": {
        "name": "routeAfterEvaluationApproval",
        "handler": {
          "parameters": [
            {
              "name": "state",
              "parameterType": "state",
              "stateType": "typeof AgentState.State"
            }
          ],
          "function": "if (state.currentPhase === 'completed') {\n  return '__end__';\n}\nreturn 'orchestrator';"
        }
      }
    }
  ],
  "stateGraph": {
    "annotationRef": "AgentState",
    "config": {
      "checkpointer": {
        "type": "MemorySaver"
      }
    }
  },
  "a2aServers": {
    "task_agent": {
      "cardUrl": "http://localhost:3001/.well-known/agent.json",
      "timeout": 30000
    },
    "research_agent": {
      "cardUrl": "http://localhost:3002/.well-known/agent.json",
      "timeout": 30000
    },
    "quality_agent": {
      "cardUrl": "http://localhost:3003/.well-known/agent.json",
      "timeout": 30000
    }
  }
}