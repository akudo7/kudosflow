{
  "config": {
    "recursionLimit": 100,
    "eventEmitter": {
      "defaultMaxListeners": 20
    }
  },
  "a2aClients": {
    "task_agent": {
      "cardUrl": "http://localhost:3001/.well-known/agent.json",
      "timeout": 30000
    },
    "research_agent": {
      "cardUrl": "http://localhost:3002/.well-known/agent.json",
      "timeout": 30000
    },
    "quality_agent": {
      "cardUrl": "http://localhost:3003/.well-known/agent.json",
      "timeout": 30000
    }
  },
  "stateAnnotation": {
    "name": "AgentState",
    "type": "Annotation.Root"
  },
  "annotation": {
    "messages": {
      "type": "BaseMessage[]",
      "reducer": "(x, y) => x.concat(y)",
      "default": []
    },
    "currentPhase": {
      "type": "string",
      "reducer": "(x, y) => y || x",
      "default": "task_creation"
    },
    "approvalPending": {
      "type": "boolean",
      "reducer": "(x, y) => y !== undefined ? y : x",
      "default": false
    },
    "tasksApproved": {
      "type": "boolean",
      "reducer": "(x, y) => y !== undefined ? y : x",
      "default": false
    },
    "researchCompleted": {
      "type": "boolean",
      "reducer": "(x, y) => y !== undefined ? y : x",
      "default": false
    },
    "qualityEvaluated": {
      "type": "boolean",
      "reducer": "(x, y) => y !== undefined ? y : x",
      "default": false
    },
    "taskListData": {
      "type": "any",
      "reducer": "(x, y) => y || x",
      "default": null
    }
  },
  "models": [
    {
      "id": "mainModel",
      "type": "OpenAI",
      "config": {
        "model": "gpt-4o-mini",
        "temperature": 0.7
      },
      "bindA2AClients": true,
      "systemPrompt": "You are a BizDev Market Analysis Orchestrator Agent. Your role is to coordinate market research by delegating tasks to specialized agents."
    }
  ],
  "nodes": [
    {
      "id": "orchestrator",
      "function": {
        "parameters": [
          {
            "name": "state",
            "type": "typeof AgentState.State"
          },
          {
            "name": "model",
            "type": "ModelConfig",
            "modelRef": "mainModel"
          }
        ],
        "output": {
          "messages": "Message[]",
          "currentPhase": "string"
        },
        "implementation": "try {\n  console.log('ðŸŽ¯ [orchestrator] Current phase:', state.currentPhase);\n  const currentPhase = state.currentPhase || 'task_creation';\n  if (currentPhase === 'task_creation' && !state.tasksApproved) {\n    console.log('ðŸŽ¯ [orchestrator] Phase 1: Calling task agent');\n    const userContent = state.messages.find(msg => msg.content)?.content || 'Please create research tasks.';\n    const response = await model.invoke([\n       { role: 'system', content: 'Use send_message_to_task_agent tool to create research tasks.'}, \n       { role: 'user', content: userContent}\n    ]);\n    return { messages: [response], currentPhase: 'task_creation' }; \n  } else \n  if (currentPhase === 'research_execution' && state.tasksApproved) {\n    console.log('ðŸŽ¯ [orchestrator] Phase 2: Starting research execution');\n    const response = await model.invoke([\n      { role: 'system', content: 'Use send_message_to_research_agent tool.' },\n      { role: 'user', content: 'Execute research based on approved tasks.' }\n    ]);\n    return { messages: [response], currentPhase: 'research_execution' };\n  }\n  console.log('ðŸŽ¯ [orchestrator] No action needed');\n  return { messages: [], currentPhase }; \n}\ncatch (error) {\n  console.error('ðŸŽ¯ [orchestrator] Error:', error);\n  return { \n    messages: [{ role: 'assistant', content: `Error: ${error.message}` }],\n    currentPhase: 'error'\n  };\n}"
      }
    },
    {
      "id": "tools",
      "type": "ToolNode",
      "useA2AClients": true
    },
    {
      "id": "approval_handler",
      "function": {
        "parameters": [
          {
            "name": "state",
            "type": "typeof AgentState.State"
          }
        ],
        "output": {
          "messages": "Message[]",
          "tasksApproved": "boolean",
          "currentPhase": "string",
          "taskListData": "any"
        },
        "implementation": "console.log('ðŸ” [approval_handler] Processing');\nconst lastToolResult = state.messages.filter(msg => (msg._getType && msg._getType() === 'tool') || msg.role === 'tool').pop();\nif (lastToolResult && lastToolResult.name === 'send_message_to_task_agent') {\n  console.log('ðŸ” [approval_handler] Checking task agent response');\n  let parsedContent;\n  try {\n    parsedContent = typeof lastToolResult.content === 'string' ? JSON.parse(lastToolResult.content) : lastToolResult.content;\n  } \n  catch (e) {\n    return {\n      messages: [], \n      tasksApproved: false,\n      currentPhase: state.currentPhase,\n      taskListData: null\n    }; \n  } \n  let taskList = [];\n  if (parsedContent.response && parsedContent.response.content) {\n    try {\n      const innerContent = typeof parsedContent.response.content === 'string' ? JSON.parse(parsedContent.response.content) : parsedContent.response.content;\n      taskList = innerContent.result?.taskList || [];\n    }\n    catch (e) {}\n  }\n  console.log('ðŸ” [approval_handler] Found taskList:', taskList.length);\n  if (taskList.length > 0 && !state.tasksApproved) {\n    const taskSummary = taskList.map((t, i) => `${i + 1}. ${t.objective} (${t.estimated_effort || 'N/A'})`).join('\\n');\n    const totalHours = taskList.reduce((sum, t) => sum + (parseInt(t.estimated_effort) || 0), 0);\n    const message = `TaskCreationAgent created ${taskList.length} tasks (${totalHours} hours):\\n\\n${taskSummary}\\n\\nApprove to proceed?`;\n    console.log('â¸ï¸ [approval_handler] Requesting approval');\n    const userResponse = interrupt(message);\n    console.log('â¸ï¸ [approval_handler] User response:', userResponse);\n    if (!userResponse) {\n      return {\n        messages: [],\n        tasksApproved: false,\n        currentPhase: 'awaiting_approval',\n        taskListData: taskList\n      };\n    }\n    const response = String(userResponse).toLowerCase().trim();\n    if (response === 'approve' || response.includes('yes')) {\n      console.log('âœ… [approval_handler] Approved');\n      return {\n        messages: [\n          { role: 'assistant', content: 'Tasks approved. Starting research.' }\n        ],\n        tasksApproved: true,\n        currentPhase: 'research_execution',\n        taskListData: taskList\n      };\n    } else {\n      console.log('âŒ [approval_handler] Rejected');\n      return {\n        messages: [\n          { role: 'assistant', content: 'Tasks rejected.'}\n        ], \n        tasksApproved: false,\n        currentPhase: 'task_creation',\n        taskListData: null\n      };\n    }\n  }\n}\nreturn {\n  messages: [],\n  tasksApproved: state.tasksApproved,\n  currentPhase: state.currentPhase,\n  taskListData: state.taskListData\n};"
      }
    }
  ],
  "edges": [
    {
      "from": "__start__",
      "to": "orchestrator"
    },
    {
      "from": "tools",
      "to": "approval_handler"
    },
    {
      "from": "approval_handler",
      "to": "orchestrator"
    },
    {
      "from": "orchestrator",
      "type": "conditional",
      "condition": {
        "name": "shouldContinue",
        "function": {
          "parameters": [
            {
              "name": "state",
              "type": "typeof AgentState.State"
            }
          ],
          "output": "string",
          "implementation": "const lastMessage = state.messages[state.messages.length - 1];\nif (lastMessage && lastMessage.tool_calls && lastMessage.tool_calls.length > 0) {\n  return 'tools';\n}\nif (state.currentPhase === 'error' || state.currentPhase === 'completed') {\n  return '__end__';\n}\nif (state.currentPhase === 'awaiting_approval') {\n  return '__end__';\n}\nif (state.currentPhase === 'research_execution' && state.tasksApproved) {\n  return 'orchestrator';\n}\nreturn '__end__';"
        }
      },
      "possibleTargets": ["tools", "orchestrator", "__end__"]
    }
  ],
  "stateGraph": {
    "annotationRef": "AgentState",
    "config": {
      "checkpointer": {
        "type": "MemorySaver"
      }
    }
  }
}
