{
  "config": {
    "recursionLimit": 50,
    "eventEmitter": {
      "defaultMaxListeners": 20
    },
    "a2aEndpoint": {
      "agentCard": {
        "name": "ResearchExecutionAgent",
        "description": "Executes market research tasks using external data collection tools. Performs comprehensive data gathering, analysis, and synthesis for business development insights.",
        "protocolVersion": "0.3.0",
        "version": "1.0.0",
        "url": "http://localhost:3002/",
        "endpoints": {
          "messageSend": "http://localhost:3002/message/send",
          "messageStream": "http://localhost:3002/message/stream",
          "taskGet": "http://localhost:3002/tasks/{taskId}",
          "taskCancel": "http://localhost:3002/tasks/{taskId}/cancel"
        },
        "capabilities": {
          "streaming": false,
          "pushNotifications": false,
          "stateTransitionHistory": true
        },
        "skills": [
          {
            "id": "web_search",
            "name": "Web Search",
            "description": "Comprehensive web search and data collection",
            "tags": [
              "research",
              "data"
            ]
          },
          {
            "id": "data_collection",
            "name": "Data Collection",
            "description": "Systematic data gathering from multiple sources",
            "tags": [
              "research",
              "analysis"
            ]
          },
          {
            "id": "content_extraction",
            "name": "Content Extraction",
            "description": "Extraction and processing of relevant content",
            "tags": [
              "processing",
              "analysis"
            ]
          },
          {
            "id": "market_analysis",
            "name": "Market Analysis",
            "description": "Analysis of market trends and business insights",
            "tags": [
              "analysis",
              "market"
            ]
          }
        ]
      },
      "port": 3002,
      "executor": {
        "type": "AgentExecutor",
        "config": {
          "taskLifecycle": true,
          "streaming": false,
          "errorHandling": "standard"
        }
      }
    },
    "mcpServers": {
      "config": {
        "throwOnLoadError": false,
        "prefixToolNameWithServerName": true,
        "additionalToolNamePrefix": "mcp"
      }
    }
  },
  "stateAnnotation": {
    "name": "AgentState",
    "type": "Annotation.Root"
  },
  "annotation": {
    "messages": {
      "type": "BaseMessage[]",
      "reducer": "(x, y) => x.concat(y)",
      "default": []
    },
    "researchQuery": {
      "type": "string",
      "reducer": "(x, y) => y || x",
      "default": ""
    },
    "researchResults": {
      "type": "string[]",
      "reducer": "(x, y) => x.concat(y)",
      "default": []
    },
    "executionStep": {
      "type": "string",
      "reducer": "(x, y) => y || x",
      "default": "start"
    }
  },
  "models": [
    {
      "id": "researchModel",
      "type": "OpenAI",
      "config": {
        "model": "gpt-4o-mini",
        "temperature": 0.3
      },
      "bindMcpServers": true,
      "systemPrompt": "You are a Research Execution Agent. Execute research tasks efficiently using available tools. Focus on gathering accurate, current information about companies, products, and market trends. Always provide structured, well-sourced results."
    }
  ],
  "mcpServers": {
    "web-search": {
      "transport": "stdio",
      "command": "node",
      "args": [
        "/Users/akirakudo/Desktop/MyWork/MPC/web-search/build/index.js"
      ]
    }
  },
  "nodes": [
    {
      "id": "task_receiver",
      "function": {
        "parameters": [
          {
            "name": "state",
            "type": "typeof AgentState.State"
          }
        ],
        "output": {
          "messages": "string[]",
          "researchQuery": "string",
          "executionStep": "string"
        },
        "implementation": "try {\n  const lastMessage = state.messages[state.messages.length - 1];\n  let messageContent = '';\n  if (lastMessage) {\n    if (typeof lastMessage === 'string') {\n      messageContent = lastMessage;\n    } else\n    if (lastMessage.content) {\n      messageContent = lastMessage.content;\n    } else\n    if (lastMessage.parts && Array.isArray(lastMessage.parts) && lastMessage.parts.length > 0) {\n      messageContent = lastMessage.parts[0].text || lastMessage.parts[0].content || '';\n    }\n  }\n  console.log('ðŸ“¥ [task_receiver] Processing:', messageContent.substring(0, 100));\n  if (messageContent && messageContent.length > 0) {\n    return {\n      messages: [`Research task received: ${messageContent.substring(0, 200)}...`],\n      researchQuery: messageContent,\n      executionStep: 'research'\n    };\n  }\n  return {\n    messages: ['Ready to receive research tasks.'],\n    researchQuery: '',\n    executionStep: 'waiting'\n  };\n}\ncatch (error) {\n  console.error('ðŸ“¥ [task_receiver] Error:', error);\n  return {\n    messages: ['Error processing task request.'],\n    researchQuery: '',\n    executionStep: 'error'\n  };\n}"
      }
    },
    {
      "id": "research_executor",
      "function": {
        "parameters": [
          {
            "name": "state",
            "type": "typeof AgentState.State"
          },
          {
            "name": "model",
            "type": "ModelConfig",
            "modelRef": "researchModel"
          }
        ],
        "output": {
          "messages": "string[]",
          "executionStep": "string"
        },
        "implementation": "try {\n  console.log('ðŸ”¬ [research_executor] Starting comprehensive research');\n  const query = state.researchQuery || 'general research';\n  console.log('ðŸ”¬ [research_executor] Query:', query.substring(0, 100));\n  const messages = [\n    { role: 'user', content: `Research the following topic comprehensively: ${query}. Provide detailed information including company overview, establishment year, business operations, main markets, and recent developments. Use web search tools to gather current and accurate information.` }\n  ];\n  let currentMessages = [...messages];\n  let attempts = 0;\n  const maxAttempts = 3;\n  let finalResult = '';\n  while (attempts < maxAttempts) {\n    attempts++; console.log(`ðŸ”¬ [research_executor] Attempt ${attempts}/${maxAttempts}`);\n    const response = await model.invoke(currentMessages);\n    console.log('ðŸ”¬ [research_executor] Response type:', typeof response);\n    console.log('ðŸ”¬ [research_executor] Has tool_calls:', !!(response && response.tool_calls && response.tool_calls.length > 0));\n    if (response && response.tool_calls && response.tool_calls.length > 0) {\n      console.log('ðŸ”¬ [research_executor] Processing tool calls:', response.tool_calls.length);\n      currentMessages.push(response);\n      for (const toolCall of response.tool_calls) {\n        console.log('ðŸ”¬ [research_executor] Tool call:', toolCall.name, toolCall.args);\n        let toolResult = 'Tool execution completed successfully.';\n        try {\n          if (toolCall.name.includes('search')) {\n            toolResult = `Search results for \"${toolCall.args.query}\": Found relevant information about the company including business overview, market position, and operational details.`;\n          }\n        }\n        catch (toolError) {\n          console.error('ðŸ”¬ [research_executor] Tool error:', toolError);\n          toolResult = `Tool execution encountered an issue: ${toolError.message}`;\n        }\n        currentMessages.push({ role: 'tool', content: toolResult, tool_call_id: toolCall.id, name: toolCall.name });\n      }\n    } else\n    if (response && response.content) {\n      finalResult = response.content;\n      console.log('ðŸ”¬ [research_executor] Final result length:', finalResult.length);\n      break;\n    } else {\n      finalResult = 'Research completed but no detailed content was generated.';\n      break;\n    }\n  }\n  if (!finalResult && currentMessages.length > 1) {\n    const finalResponse = await model.invoke([...currentMessages, { role: 'user', content: 'Please provide a comprehensive summary of the research findings.' }]);\n    finalResult = finalResponse.content || 'Research summary could not be generated.';\n  }\n  console.log('ðŸ”¬ [research_executor] Final result preview:', finalResult.substring(0, 200));\n  return {\n    messages: [finalResult],\n    executionStep: 'completed'\n  };\n}\ncatch (error) {\n  console.error('ðŸ”¬ [research_executor] Error:', error);\n  return {\n    messages: [`Research execution failed: ${error.message || error}`],\n    executionStep: 'error'\n  };\n}"
      }
    },
    {
      "id": "result_formatter",
      "function": {
        "parameters": [
          {
            "name": "state",
            "type": "typeof AgentState.State"
          },
          {
            "name": "model",
            "type": "ModelConfig",
            "modelRef": "researchModel"
          }
        ],
        "output": {
          "messages": "string[]",
          "researchResults": "string[]",
          "executionStep": "string"
        },
        "implementation": "try {\n  const lastMessage = state.messages[state.messages.length - 1];\n  let contentToFormat = '';\n  if (typeof lastMessage === 'string') {\n    contentToFormat = lastMessage;\n  } else\n  if (lastMessage && typeof lastMessage === 'object' && lastMessage.content) {\n    contentToFormat = lastMessage.content;\n  } else {\n    contentToFormat = 'No content available for formatting';\n  }\n  console.log('ðŸ“‹ [result_formatter] Content length:', contentToFormat.length);\n  if (contentToFormat.length < 50) {\n    return {\n      messages: ['Insufficient content for formatting.'],\n      researchResults: [],\n      executionStep: 'completed'\n    };\n  }\n  const formatPrompt = `Format the following research results into a well-structured summary with clear sections for: 1) Company Overview, 2) Key Findings, 3) Business Operations, 4) Market Position, 5) Sources and References. Content to format: ${contentToFormat}`;\n  const formattedResponse = await model.invoke([{ role: 'user', content: formatPrompt }]);\n  const formattedContent = formattedResponse.content || formattedResponse.toString();\n  const result = { timestamp: new Date().toISOString(), query: state.researchQuery, findings: formattedContent, status: 'completed' };\n  return {\n    messages: [formattedContent],\n    researchResults: [JSON.stringify(result)],\n    executionStep: 'completed'\n  };\n}\ncatch (error) {\n  console.error('ðŸ“‹ [result_formatter] Error:', error);\n  return {\n    messages: [`Formatting failed: ${error.message || error}`],\n    researchResults: [],\n    executionStep: 'error'\n  };\n}"
      }
    }
  ],
  "edges": [
    {
      "from": "__start__",
      "to": "task_receiver"
    },
    {
      "from": "research_executor",
      "to": "result_formatter"
    },
    {
      "from": "result_formatter",
      "to": "__end__"
    },
    {
      "from": "task_receiver",
      "type": "conditional",
      "condition": {
        "name": "shouldProceed",
        "function": {
          "parameters": [
            {
              "name": "state",
              "type": "typeof AgentState.State"
            }
          ],
          "output": "string",
          "implementation": "try {\n  const step = state.executionStep || 'waiting';\n  console.log('ðŸ”€ [shouldProceed] Current step:', step);\n  if (step === 'research') {\n    return 'research_executor';\n  }\n  if (step === 'error') {\n    return '__end__';\n  }\n  return '__end__';\n}\ncatch (error) {\n  console.error('ðŸ”€ [shouldProceed] Error:', error);\n  return '__end__';\n}"
        }
      },
      "possibleTargets": ["research_executor", "__end__"]
    }
  ],
  "stateGraph": {
    "annotationRef": "AgentState",
    "config": {
      "checkpointer": {
        "type": "MemorySaver"
      }
    }
  }
}